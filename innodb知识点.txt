普通锁:操作前锁住,行锁
读写锁:可实现读读并发
数据多版本(核心原理:克隆数据,读旧版本数据, 写操作新克隆的数据):实现读写并发

-----------------------------------------------

redo,undo,回滚段
redo:
1.修改行为实现顺序写到redo日志,定期刷到磁盘上,将随机写优化为顺序写
2.数据库奔溃重启会重做redo日志里的操作,保证已提交事务的acid
undo:
1.将修改前的数据存放undo日志,回滚时恢复旧版本数据
2.保证未提交事务的acid
回滚段:
存储undo日志的地方就是回滚段
事务提交时回滚段的日志可以删除

-------------------------------------------------

MVCC
就是多版本并发控制,核心原理就是读的时候是读旧数据,写的时候操作做的是新克隆的数据,实现读写并发
这就是快照读,是innodb高并发的核心原因之一

-------------------------------------------------

不可重复读与幻读的区别
不可重复读 的重点是针对 update,其他事务发生这种操作时,本事务进行两次相同的查询发现数据不一致,即为不可重复读.
幻读 的重点针对的是 insert, delete, 其他事务发生这两种操作时,本事务进行插入发现数据已存在,即为幻读.
所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。

"可以理解成,避免不可重复读需要锁行就行
避免幻影读则需要锁表"

"当然, 从总的结果来看, 似乎两者都表现为两次读取的结果不一致.
但如果你从控制的角度来看, 两者的区别就比较大
对于前者, 只需要锁住满足条件的记录
对于后者, 要锁住满足条件及其相近的记录"
"不可重复读的重点是修改:
同样的条件, 你读取过的数据, 再次读取出来发现值不一样了
幻读的重点在于新增或者删除
同样的条件, 第1次和第2次读出来的记录数不一样"

----------------------------------------------------

innodb的7种锁
自增锁,共享/排他锁,意向锁,插入意向锁,记录锁,间隙锁,临键锁.

意向锁:
设 A:某行加读锁 B:想加表锁
这时B的判断是:
step1：判断表是否已被其他事务用表锁锁表
step2：判断表中的每一行是否已被行锁锁住。
若使用意向锁,A必须先申请表的意向共享锁，成功后再申请一行的行锁
这样B的判断步骤变为:
step1：不变
step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。
