### Keep-Alive
在没用keep-alive时:

* 浏览器请求//static.mtime.cn/a.js-->解析域名-->HTTP连接-->服务器处理文件-->返回数据-->浏览器解析、渲染文件
* 浏览器请求//static.mtime.cn/b.js-->解析域名-->HTTP连接-->服务器处理文件-->返回数据-->浏览器解析、渲染文件

### Keep-Alive解决的问题
Keep-Alive解决的核心问题：一定时间内，同一域名多次请求数据，只建立一次HTTP请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。这里面所说的一定时间是可以配置的，不管你用的是Apache还是nginx。

### http1.1使用keep-alive后
* 第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）
* 第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。

### http2.0
* HTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。

![image](https://segmentfault.com/img/bVUSLx?w=562&h=375)

### 所以多路复用:
在结合了keep-alive的只需一次连接以及以流的形式传输,实现了:一个域只要一个TCP连接实现真正的并发请求，降低延时，提高了带宽的利用率。

[摘自:https://segmentfault.com/a/1190000011172823](https://segmentfault.com/a/1190000011172823)

### webstocket
WebSocket是一种在单个TCP连接上进行全双工通讯的协议

流程:
> 客户端派发一个信使向服务器送信，服务器扮演的“守门人”检查信件，发现信件中写到“让我们用更加潮流的WebSocket方式交流吧”，服务器在在信件末尾添加上一句“没问题，浏览器伙计”，让信使原路返回告知浏览器。当浏览器再次向服务器告知收到消息时（第三次握手），服务器就开始运转“邮局”，向客户端派发信使与浏览器互发信息，转发资源。

实现跨域访问:
> 当客户端与服务端创建WebSocket连接后，本身就可以天然的实现跨域资源共享，WebSocket协议本身就不受浏览器“同源策略”的限制（还记得吧，同源策略只是限制了跨域的AJAX请求？），所以问题本身就不成立（有点赖皮是吧？）。
> 客户端和服务端一旦建立连接，就可以顺畅的互发数据，因此WebSocket协议本身就是“有状态的”，不需要Cookie的帮忙，既然没有Cookie，自然也不需要“同源策略”去保护，因此其实这个问题也不成立。
[详见](https://segmentfault.com/a/1190000012370451)

### nginx 慕课
IO多路复用, 以学生与老师为例:

* 首先,串型的方式 相当于一个老师等一个学生遇到问题问完问题后才能进行下一个学生的解答
* 多线程方式 相当于多个老师针对每一个学生一对一进行解答
* IO复用方式 相当于多个学生遇到不会的找老师解答,其他学生继续做题,刚好也有问题等前一个问完再主动去问

学生为请求(多个IO流), 老师为线程, io复用指的就是复用一个线程

io多路复用有select poll epoll

select httpserver将自己所要读写的stocket的fd全都发给操作系统, 等操作系统发现stocket是可以读写的返回,httpserver遍历队列内容发现有读写的stocket, 效率低, 有限制

epoll 是在操作系统返回的时候告诉应用nginx哪些stocket是可以读写的,不需要遍历
> I/O multiplexing 这里面的 multiplexing 指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态(对应空管塔里面的Fight progress strip槽)来同时管理多个I/O流. 发明它的原因，是尽量多的提高服务器的吞吐能力。

#### IO中的同步,异步,阻塞,非阻塞
> 同步: 同步体现在, 在等待一件事情的处理结果时, 对方是否提供通知服务, 如果对方不提供通知服务, 则为 同步;
> 异步: 异步体现在, 在等待一件事情的处理结果时, 对方是否提供通知服务, 如果对方提供通知服务, 则为 异步;
> 阻塞: 阻塞体现在, 在等待一件事情的处理结果时, 你是否还去干点其他的事情, 如果不去, 则为 阻塞;
> 非阻塞: 非阻塞体现在, 在等待一件事情的处理结果时, 你是否还去干点其他的事情, 如果去了, 则为 非阻塞;

同步io分为:阻塞io, 非阻塞io,io多路复用
异步io:异步io           [详见](https://segmentfault.com/a/1190000003063859)
